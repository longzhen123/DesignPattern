# DesignPattern
设计模式学习

## 七大设计原则

### 单一职责原则
对类来说的，即一个类应该只负责一项职责。如类A负责两个不同职责：职责1，职责2。
当职责1需求变更而改变A时，可能造成职责2执行错误，所以需要将类A的粒度分解为
A1，A2

### 接口隔离原则
客户端不应该依赖它不需要的接口，即一个类对另一个类的依赖应该建立在最小的接口上

### 依赖倒转原则
1) 高层模块不应该依赖低层模块，二者都应该依赖其抽象
2) 抽象不应该依赖细节，细节应该依赖抽象
3) 依赖倒转(倒置)的中心思想是面向接口编程
4) 依赖倒转原则是基于这样的设计理念：相对于细节的多变性，抽象的东西要稳定的
   多。以抽象为基础搭建的架构比以细节为基础的架构要稳定的多。在java中，抽象
   指的是接口或抽象类，细节就是具体的实现类
5) 使用接口或抽象类的目的是制定好规范，而不涉及任何具体的操作，把展现细节的
   任务交给他们的实现类去完成

### 里氏替换原则
如果对每个类型为T1的对象o1，都有类型为T2的对象o2，使得以T1定义的所有程序
P在所有的对象o1都代换成o2时，程序P的行为没有发生变化，那么类型T2是类型T1
的子类型。换句话说，所有引用基类的地方必须能透明地使用其子类的对象。

### 开闭原则
1) 开闭原则（Open Closed Principle）是编程中最基础、最重要的设计原则
2) 一个软件实体如类，模块和函数应该对扩展开放(对提供方)，对修改关闭(对使用
   方)。用抽象构建框架，用实现扩展细节。
3) 当软件需要变化时，尽量通过扩展软件实体的行为来实现变化，而不是通过修改已
   有的代码来实现变化。
4) 编程中遵循其它原则，以及使用设计模式的目的就是遵循开闭原则。

### 迪米特法则
1) 一个对象应该对其他对象保持最少的了解
2) 类与类关系越密切，耦合度越大
3) 迪米特法则(Demeter Principle)又叫最少知道原则，即一个类对自己依赖的类知道的
   越少越好。也就是说，对于被依赖的类不管多么复杂，都尽量将逻辑封装在类的内
   部。对外除了提供的public 方法，不对外泄露任何信息
4) 迪米特法则还有个更简单的定义：只与直接的朋友通信

### 合成复用原则
尽量使用合成/聚合的方式，而不是使用继承

## 单例模式
单例模式有八种方式：
1) 饿汉式(静态常量)
2) 饿汉式（静态代码块）
3) 懒汉式(线程不安全)
4) 懒汉式(线程安全，同步方法)
5) 懒汉式(线程安全，同步代码块)
6) 双重检查
7) 静态内部类
8) 枚举

## 饿汉式（静态常量）
步骤如下：
1) 构造器私有化 (防止 new )
2) 类的内部创建对象
3) 向外暴露一个静态的公共方法。getInstance
4) 代码实现

优缺点说明：
1) 优点：这种写法比较简单，就是在类装载的时候就完成实例化。避免了线程同
   步问题。
2) 缺点：在类装载的时候就完成实例化，没有达到Lazy Loading的效果。如果从始
   至终从未使用过这个实例，则会造成内存的浪费
3) 这种方式基于classloder机制避免了多线程的同步问题，不过，instance在类装载
   时就实例化，在单例模式中大多数都是调用getInstance方法， 但是导致类装载
   的原因有很多种，因此不能确定有其他的方式（或者其他的静态方法）导致类
   装载，这时候初始化instance就没有达到lazy loading的效果
4) 结论：这种单例模式可用，可能造成内存浪费

## 饿汉式（静态代码块）
优缺点说明：
1) 这种方式和上面的方式其实类似，只不过将类实例化的过程放在了静态代码块
   中，也是在类装载的时候，就执行静态代码块中的代码，初始化类的实例。优
   缺点和上面是一样的。
2) 结论：这种单例模式可用，但是可能造成内存浪费

## 懒汉式(线程不安全)
1) 起到了Lazy Loading的效果，但是只能在单线程下使用
2) 如果在多线程下，一个线程进入了if (singleton == null)判断语句块，还未来得及
   往下执行，另一个线程也通过了这个判断语句，这时便会产生多个实例。所以
   在多线程环境下不可使用这种方式
3) 结论：在实际开发中，不要使用这种方式

## 懒汉式（线程安全）
1) 解决了线程不安全问题
2) 效率太低了，每个线程在想获得类的实例时候，执行getInstance()方法都要进行
   同步。而其实这个方法只执行一次实例化代码就够了，后面的想获得该类实例，
   直接return就行了。方法进行同步效率太低
3) 结论：在实际开发中，不推荐使用这种方式

## 懒汉式(线程安全，同步代码块)
优缺点说明：
1) 这种方式，本意是想对第四种实现方式的改进，因为前面同步方法效率太低，
   改为同步产生实例化的的代码块
2) 但是这种同步并不能起到线程同步的作用。跟第3种实现方式遇到的情形一
   致，假如一个线程进入了if (singleton == null)判断语句块，还未来得及往下执行，
   另一个线程也通过了这个判断语句，这时便会产生多个实例
3) 结论：在实际开发中，不能使用这种方式

## 双重检查
优缺点说明：
1) Double-Check概念是多线程开发中常使用到的，如代码中所示，我们进行了两
   次if (singleton == null)检查，这样就可以保证线程安全了。
2) 这样，实例化代码只用执行一次，后面再次访问时，判断if (singleton == null)，
   直接return实例化对象，也避免的反复进行方法同步.
3) 线程安全；延迟加载；效率较高
4) 结论：在实际开发中，推荐使用这种单例设计模式

## 静态内部类
优缺点说明：
1) 这种方式采用了类装载的机制来保证初始化实例时只有一个线程。
2) 静态内部类方式在Singleton类被装载时并不会立即实例化，而是在需要实例化
   时，调用getInstance方法，才会装载SingletonInstance类，从而完成Singleton的
   实例化。
3) 类的静态属性只会在第一次加载类的时候初始化，所以在这里，JVM帮助我们
   保证了线程的安全性，在类进行初始化时，别的线程是无法进入的。
4) 优点：避免了线程不安全，利用静态内部类特点实现延迟加载，效率高
5) 结论：推荐使用

## 枚举
优缺点说明：
1) 这借助JDK1.5中添加的枚举来实现单例模式。不仅能避免多线程同步问题，而
   且还能防止反序列化重新创建新的对象。
2) 这种方式是Effective Java作者Josh Bloch 提倡的方式
3) 结论：推荐使用

## 单例模式注意事项和细节说明
1) 单例模式保证了 系统内存中该类只存在一个对象，节省了系统资源，对于一些需
   要频繁创建销毁的对象，使用单例模式可以提高系统性能
2) 当想实例化一个单例类的时候，必须要记住使用相应的获取对象的方法，而不是使
   用new
3) 单例模式使用的场景：需要频繁的进行创建和销毁的对象、创建对象时耗时过多或
   耗费资源过多(即：重量级对象)，但又经常用到的对象、工具类对象、频繁访问数
   据库或文件的对象(比如数据源、session工厂等)

## 简单工厂模式
### 传统方式
1) 优点是比较好理解，简单易操作。
2) 缺点是违反了设计模式的ocp原则，即对扩展开放，对修改关闭。即当我们给类增
   加新功能的时候，尽量不修改代码，或者尽可能少修改代码.
3) 比如我们这时要新增加一个Pizza的种类(Pepper披萨)，我们需要做如下修改.

```java
//增加一段代码 OrderPizza.java //写
if (ordertype.equals("greek")) {
pizza = new GreekPizza();
} else if (ordertype.equals("pepper")) {
pizza = new PepperPizza();
} else if (ordertype.equals("cheese")) {
pizza = new CheesePizza();
} else {
break;
}}
```

### 简单工厂模式
1) 简单工厂模式是属于创建型模式，是工厂模式的一种。简单工厂模式是由一
   个工厂对象决定创建出哪一种产品类的实例。简单工厂模式是工厂模式家族
   中最简单实用的模式
2) 简单工厂模式：定义了一个创建对象的类，由这个类来封装实例化对象的行
   为(代码)
3) 在软件开发中，当我们会用到大量的创建某种、某类或者某批对象时，就会
   使用到工厂模式
4) 改进的思路分析：
   分析：修改代码可以接受，但是如果我们在其它的地方也有创建Pizza的代码，就意味
   着，也需要修改，而创建Pizza的代码，往往有多处。
   思路：把创建Pizza对象封装到一个类中，这样我们有新的Pizza种类时，只需要修改该
   类就可，其它有创建到Pizza对象的代码就不需要修改了.-> 简单工厂模式

### 工厂方法模式
工厂方法模式设计方案：将披萨项目的实例化功能抽象成抽象方法，在不同的口味点
餐子类中具体实现。
工厂方法模式：定义了一个创建对象的抽象方法，由子类决定要实例化的类。工厂方
法模式将对象的实例化推迟到子类。


### 抽象工厂模式
1) 抽象工厂模式：定义了一个interface用于创建相关或有依赖关系的对象簇，而无需
   指明具体的类
2) 抽象工厂模式可以将简单工厂模式和工厂方法模式进行整合。
3) 从设计层面看，抽象工厂模式就是对简单工厂模式的改进(或者称为进一步的抽象)。
4) 将工厂抽象成两层，AbsFactory(抽象工厂) 和 具体实现的工厂子类。程序员可以
   根据创建对象类型使用对应的工厂子类。这样将单个的简单工厂类变成了工厂簇，
   更利于代码的维护和扩展。

## 原型模式
传统的方式的优缺点：
1) 优点是比较好理解，简单易操作。
2) 在创建新的对象时，总是需要重新获取原始对象的属性，如果创建的对象比较复杂
   时，效率较低
3) 总是需要重新初始化对象，而不是动态地获得对象运行时的状态, 不够灵活
4) 改进的思路分析
   思路：Java中Object类是所有类的根类，Object类提供了一个clone()方法，该方法可以
   将一个Java对象复制一份，但是需要实现clone的Java类必须要实现一个接口Cloneable，
   该接口表示该类能够复制且具有复制的能力 => 原型模式

原型模式：
1) 原型模式(Prototype模式)是指：用原型实例指定创建对象的种类，并且通过拷
   贝这些原型，创建新的对象
2) 原型模式是一种创建型设计模式，允许一个对象再创建另外一个可定制的对象，
   无需知道如何创建的细节
3) 工作原理是:通过将一个原型对象传给那个要发动创建的对象，这个要发动创建
   的对象通过请求原型对象拷贝它们自己来实施创建，即 对象.clone()

好处：传统方法通过new创建多个对象，当增加新的成员变量时，要更改所有代码。原型模式则不用。

**注意**：clone方法默认使用浅拷贝。当成员变量是引用类型时，仅仅是复制引用，并没有重新创建成员变量。

深拷贝两种思路：
1) 引用类型的成员变量的clone方法
2) 将源对象序列化，然后进行反序列化

## 建造者模式
好处：将对象和对象的构造解耦

基本介绍：
1) 建造者模式（Builder Pattern） 又叫生成器模式，是一种对象构建模式。它可以
   将复杂对象的建造过程抽象出来（抽象类别），使这个抽象过程的不同实现方
   法可以构造出不同表现（属性）的对象。
2) 建造者模式是一步一步创建一个复杂的对象，它允许用户只通过指定复杂对象
   的类型和内容就可以构建它们，用户不需要知道内部的具体构建细节。

建造者模式的四个角色：
1) Product（产品角色）： 一个具体的产品对象。
2) Builder（抽象建造者）： 创建一个Product对象的各个部件指定的 接口/抽象类。
3) ConcreteBuilder（具体建造者）： 实现接口，构建和装配各个部件。
4) Director（指挥者）： 构建一个使用Builder接口的对象。它主要是用于创建一个
   复杂的对象。它主要有两个作用，一是：隔离了客户与对象的生产过程，二是：
   负责控制产品对象的生产过程

## 适配器模式
基本介绍：
1) 适配器模式(Adapter Pattern)将某个类的接口转换成客户端期望的另一个接口表
   示，主的目的是兼容性，让原本因接口不匹配不能一起工作的两个类可以协同
   工作。其别名为包装器(Wrapper)
2) 适配器模式属于结构型模式
3) 主要分为三类：类适配器模式、对象适配器模式、接口适配器模式

工作原理：
1) 适配器模式：将一个类的接口转换成另一种接口.让原本接口不兼容的类可以兼
   容
2) 从用户的角度看不到被适配者，是解耦的
3) 用户调用适配器转化出来的目标接口方法，适配器再调用被适配者的相关接口
   方法
4) 用户收到反馈结果，感觉只是和目标接口交互

### 类适配器模式
基本介绍：Adapter类，通过继承src类，实现dst类接口，完成src->dst的适配。

### 对象适配器模式
对象适配器模式介绍
1) 基本思路和类的适配器模式相同，只是将Adapter类作修改，不是继承src类，而
   是持有src类的实例，以解决兼容性的问题。 即：持有 src类，实现 dst 类接口，
   完成src->dst的适配
2) 根据“合成复用原则”，在系统中尽量使用关联关系来替代继承关系。
3) 对象适配器模式是适配器模式常用的一种

### 接口适配器模式
接口适配器模式介绍
1) 一些书籍称为：适配器模式(Default Adapter Pattern)或缺省适配器模式。
2) 当不需要全部实现接口提供的方法时，可先设计一个抽象类实现接口，并为该接
   口中每个方法提供一个默认实现（空方法），那么该抽象类的子类可有选择地覆
   盖父类的某些方法来实现需求
3) 适用于一个接口不想使用其所有的方法的情况。

## 桥接器模式
好处：让程序具有搞好的扩展性，利用程序维护

基本介绍：
1) 桥接模式(Bridge模式)是指：将实现与抽象放在两个不同的类层次中，使两个层
   次可以独立改变。
2) 是一种结构型设计模式
3) Bridge模式基于类的最小设计原则，通过使用封装、聚合及继承等行为让不同
   的类承担不同的职责。它的主要特点是把抽象(Abstraction)与行为实现
   (Implementation)分离开来，从而可以保持各部分的独立性以及应对他们的功能
   扩展

## 装饰器模式
好处：具有良好的扩展性、改动方便、维护方便

装饰者模式：动态的将新功能附加到对象上。在对象功能扩展方面，它比继承更
有弹性，装饰者模式也体现了开闭原则(ocp)

## 组合模式
基本介绍：
1) 组合模式（Composite Pattern），又叫部分整体模式，它创建了对象组的树形结
   构，将对象组合成树状结构以表示“整体-部分”的层次关系。
2) 组合模式依据树形结构来组合对象，用来表示部分以及整体层次。
3) 这种类型的设计模式属于结构型模式。
4) 组合模式使得用户对单个对象和组合对象的访问具有一致性，即：组合能让客
   户以一致的方式处理个别对象以及组合对象

## 外观模式
将子系统作为成员变量

## 享元模式
基本介绍：
1) 享元模式（Flyweight Pattern） 也叫 蝇量模式: 运
   用共享技术有效地支持大量细粒度的对象
2) 常用于系统底层开发，解决系统的性能问题。像
   数据库连接池，里面都是创建好的连接对象，在
   这些连接对象中有我们需要的则直接拿来用，避
   免重新创建，如果没有我们需要的，则创建一个
3) 享元模式能够解决重复对象的内存浪费的问题，
   当系统中有大量相似对象，需要缓冲池时。不需
   总是创建新对象，可以从缓冲池里拿。这样可以
   降低系统内存，同时提高效率
4) 享元模式经典的应用场景就是池技术了，String常
   量池、数据库连接池、缓冲池等等都是享元模式
   的应用，享元模式是池技术的重要实现方式

## 代理模式
基本介绍：
1) 代理模式：为一个对象提供一个替身，以控制对这个对象的访问。即通过代理
   对象访问目标对象.这样做的好处是:可以在目标对象实现的基础上,增强额外的
   功能操作,即扩展目标对象的功能。
2) 被代理的对象可以是远程对象、创建开销大的对象或需要安全控制的对象
3) 代理模式有不同的形式, 主要有三种 静态代理、动态代理 (JDK代理、接口代
   理)和 Cglib代理 (可以在内存动态的创建对象，而不需要实现接口， 他是属于
   动态代理的范畴) 。

### 静态代理
基本介绍：
静态代理在使用时,需要定义接口或者父类,被代理对象(即目标对象)与代理对象一
起实现相同的接口或者是继承相同父类

### 动态代理
基本介绍：
1) 代理对象,不需要实现接口，但是目标对象要实现接口，否则不能用动态代理
2) 代理对象的生成，是利用JDK的API，动态的在内存中构建代理对象
3) 动态代理也叫做：JDK代理、接口代理

#### JDK中生成代理对象的API
1) 代理类所在包:java.lang.reflect.Proxy
2) JDK实现代理只需要使用newProxyInstance方法,但是该方法需要接收三个参数,完
   整的写法是:
   static Object newProxyInstance(ClassLoader loader, Class<?>[]
   interfaces,InvocationHandler h)

#### Cglib代理
基本介绍：
1) 静态代理和JDK代理模式都要求目标对象是实现一个接口,但是有时候目标对象只
   是一个单独的对象,并没有实现任何的接口,这个时候可使用目标对象子类来实现
   代理-这就是Cglib代理
2) Cglib代理也叫作子类代理,它是在内存中构建一个子类对象从而实现对目标对象功
   能扩展, 有些书也将Cglib代理归属到动态代理。
3) Cglib是一个强大的高性能的代码生成包,它可以在运行期扩展java类与实现java接
   口.它广泛的被许多AOP的框架使用,例如Spring AOP，实现方法拦截
4) 在AOP编程中如何选择代理模式：
1. 目标对象需要实现接口，用JDK代理
2. 目标对象不需要实现接口，用Cglib代理
5) Cglib包的底层是通过使用字节码处理框架ASM来转换字节码并生成新的类


### 代理模式(Proxy)的变体
几种常见的代理模式介绍—几种变体
1) 防火墙代理
   内网通过代理穿透防火墙，实现对公网的访问。
2) 缓存代理
   比如：当请求图片文件等资源时，先到缓存代理取，如果取到资源则ok,如果取不到资源，
   再到公网或者数据库取，然后缓存。
3) 远程代理
   远程对象的本地代表，通过它可以把远程对象当本地对象来调用。远程代理通过网络和
   真正的远程对象沟通信息。

4) 同步代理：主要使用在多线程编程中，完成多线程间同步工作

## 模板方法
基本介绍：
1) 模板方法模式（Template Method Pattern），又叫模板模式(Template Pattern)，z
   在一个抽象类公开定义了执行它的方法的模板。它的子类可以按需要重写方法
   实现，但调用将以抽象类中定义的方式进行。
2) 简单说，模板方法模式 定义一个操作中的算法的骨架，而将一些步骤延迟到子
   类中，使得子类可以不改变一个算法的结构，就可以重定义该算法的某些特定
   步骤
3) 这种类型的设计模式属于行为型模式

钩子方法： 在模板方法模式的父类中，我们可以定义一个方法，它默认不做任何事，子类可以
视情况要不要覆盖它，该方法称为“钩子”。

模板方法模式的注意事项和细节
1) 基本思想是：算法只存在于一个地方，也就是在父类中，容易修改。需要修改算
   法时，只要修改父类的模板方法或者已经实现的某些步骤，子类就会继承这些修改
2) 实现了最大化代码复用。父类的模板方法和已实现的某些步骤会被子类继承而直接
   使用。
3) 既统一了算法，也提供了很大的灵活性。父类的模板方法确保了算法的结构保持不
   变，同时由子类提供部分步骤的实现。
4) 该模式的不足之处：每一个不同的实现都需要一个子类实现，导致类的个数增加，
   使得系统更加庞大
5) 一般模板方法都加上final关键字， 防止子类重写模板方法.
6) 模板方法模式使用场景：当要完成在某个过程，该过程要执行一系列步骤 ，这一
   系列的步骤基本相同，但其个别步骤在实现时 可能不同，通常考虑用模板方法模
   式来处理

## 命令模式
基本介绍：
1) 命令模式（Command Pattern）：在软件设计中，我们经常需要
   向某些对象发送请求，但是并不知道请求的接收者是谁，也不知
   道被请求的操作是哪个，
   我们只需在程序运行时指定具体的请求接收者即可，此时，可以
   使用命令模式来进行设计
2) 命名模式使得请求发送者与请求接收者消除彼此之间的耦合，让
   对象之间的调用关系更加灵活，实现解耦。
3) 在命名模式中，会将一个请求封装为一个对象，以便使用不同参
   数来表示不同的请求(即命名)，同时命令模式也支持可撤销的操作。
4) 通俗易懂的理解：将军发布命令，士兵去执行。其中有几个角色：
   将军（命令发布者）、士兵（命令的具体执行者）、命令(连接将
   军和士兵)。

## 访问者模式
基本介绍：
1) 访问者模式（Visitor Pattern），封装一些作用于某种数据结构的各元素的操作，
   它可以在不改变数据结构的前提下定义作用于这些元素的新的操作。
2) 主要将数据结构与数据操作分离，解决 数据结构和操作耦合性问题
3) 访问者模式的基本工作原理是：在被访问的类里面加一个对外提供接待访问者
   的接口
4) 访问者模式主要应用场景是：需要对一个对象结构中的对象进行很多不同操作
   (这些操作彼此没有关联)，同时需要避免让这些操作"污染"这些对象的类，可以
   选用访问者模式解决

访问者模式的注意事项和细节
优点：
1) 访问者模式符合单一职责原则、让程序具有优秀的扩展性、灵活性非常高
2) 访问者模式可以对功能进行统一，可以做报表、UI、拦截器与过滤器，适用于数据
   结构相对稳定的系统 
缺点：
1) 具体元素对访问者公布细节，也就是说访问者关注了其他类的内部细节，这是迪米
   特法则所不建议的, 这样造成了具体元素变更比较困难
2) 违背了依赖倒转原则。访问者依赖的是具体元素，而不是抽象元素
3) 因此，如果一个系统有比较稳定的数据结构，又有经常变化的功能需求，那么访问
   者模式就是比较合适的

## 迭代器模式
基本介绍：
1) 迭代器模式（Iterator Pattern）是常用的设计模式，属于行为型模式
2) 如果我们的集合元素是用不同的方式实现的，有数组，还有java的集合类，
   或者还有其他方式，当客户端要遍历这些集合元素的时候就要使用多种遍历
   方式，而且还会暴露元素的内部结构，可以考虑使用迭代器模式解决。
3) 迭代器模式，提供一种遍历集合元素的统一接口，用一致的方法遍历集合元素，
   不需要知道集合对象的底层表示，即：不暴露其内部的结构。

优点：
1) 提供一个统一的方法遍历对象，客户不用再考虑聚合的类型，使用一种方法就可以
   遍历对象了。
2) 隐藏了聚合的内部结构，客户端要遍历聚合的时候只能取到迭代器，而不会知道聚
   合的具体组成。
3) 提供了一种设计思想，就是一个类应该只有一个引起变化的原因（叫做单一责任
   原则）。在聚合类中，我们把迭代器分开，就是要把管理对象集合和遍历对象集
   合的责任分开，这样一来集合改变的话，只影响到聚合对象。而如果遍历方式改变
   的话，只影响到了迭代器。
4) 当要展示一组相似对象，或者遍历一组相同对象时使用, 适合使用迭代器模式

缺点：
每个聚合对象都要一个迭代器，会生成多个迭代器不好管理类

## 观察者模式
对象之间多对一依赖的一种设计方案，被依赖的对象为Subject，
依赖的对象为Observer，Subject通知Observer变化,比如这里的奶站是
Subject，是1的一方。用户时Observer，是多的一方

观察者模式的好处：
1) 观察者模式设计后，会以集合的方式来管理用户(Observer)，包括注册，移除
   和通知。
2) 这样，我们增加观察者(这里可以理解成一个新的公告板)，就不需要去修改核
   心类WeatherData不会修改代码，遵守了ocp原则

## 中介者模式
基本介绍：
1) 中介者模式（Mediator Pattern），用一个中介对象来封装一系列的对象交互。
   中介者使各个对象不需要显式地相互引用，从而使其耦合松散，而且可以独立
   地改变它们之间的交互
2) 中介者模式属于行为型模式，使代码易于维护
3) 比如MVC模式，C（Controller控制器）是M（Model模型）和V（View视图）的中
   介者，在前后端交互时起到了中间人的作

中介者模式的注意事项和细节：
1) 多个类相互耦合，会形成网状结构, 使用中介者模式将网状结构分离为星型结构，
   进行解耦
2) 减少类间依赖，降低了耦合，符合迪米特原则
3) 中介者承担了较多的责任，一旦中介者出现了问题，整个系统就会受到影响
4) 如果设计不当，中介者对象本身变得过于复杂，这点在实际使用时，要特别注意
